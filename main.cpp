// Подключаем библиотеку OpenMP
#include <omp.h>
// Подключаем библиотеку для работы с файлами
#include <fstream>
// Подключаем библиотеку для работы с потоками ввода-вывода
#include <iostream>
// Подключаем библиотеку для работы с математическими функциями
#include <cmath>
// Подключаем библиотеку для работы с утилитами
#include <utility>

using namespace std;

// Объявляем общую функцию для считывания числа из файла
int read_number(ifstream& file) 
{
    // Объявляем переменную для хранения числа
    int number;
    // Входим в критическую секцию, чтобы избежать конфликтов при чтении из файла
#pragma omp critical
    {
        // Считываем число из файла, если он не закончился
        if (file >> number) 
        {
            // Выводим сообщение о том, что число было считано
            cout << "[Thread " << omp_get_thread_num() << "]: read number " << number << endl;
        }
        else 
        {
            // Если файл закончился, то присваиваем числу значение -1
            number = -1;
        }
    }
    // Возвращаем считанное число
    return number;
}

// Объявляем функцию для проверки, является ли число простым
bool is_prime(int n) 
{
    // Если число меньше или равно 1, то оно не простое
    if (n <= 1) 
    {
        return false;
    }
    // Перебираем все делители от 2 до корня из числа
    for (int i = 2; i <= sqrt(n); i++) 
    {
        // Если число делится на какой-то делитель без остатка, то оно не простое
        if (n % i == 0) 
        {
            return false;
        }
    }
    // Если ни один делитель не нашелся, то число простое
    return true;
}

// Объявляем функцию для поиска наименьшего простого числа больше заданного
int find_next_prime(int n) 
{
    // Увеличиваем число на единицу, пока не найдем простое число
    do 
    {
        n++;
    } while (!is_prime(n));
    // Возвращаем найденное простое число
    return n;
}

// Объявляем функцию для поиска наибольшего числа Фибоначчи, которое не превосходит заданного
int find_max_fibonacci(int n)
{
    // Объявляем переменные для хранения двух последних чисел Фибоначчи и их суммы
    int a = 0, b = 1, c = a + b;
    // Пока сумма не превысит заданное число, продолжаем генерировать числа Фибоначчи
    while (c <= n) {
        // Присваиваем a значение b, b значение c, а c сумму a и b
        a = b;
        b = c;
        c = a + b;
    }
    // Возвращаем наибольшее число Фибоначчи, которое не превосходит заданное число
    return b;
}

// Объявляем функцию для подсчета суммы всех делителей числа, не включая само число и единицу
int sum_of_divisors(int n) 
{
    // Объявляем переменную для хранения суммы делителей
    int sum = 0;
    // Перебираем все возможные делители от 2 до корня из числа
    for (int i = 2; i <= sqrt(n); i++) 
    {
        // Если число делится на делитель без остатка, то добавляем его в сумму
        if (n % i == 0) 
        {
            sum += i;
            // Если делитель не равен квадратному корню из числа, то добавляем в сумму и частное от деления числа на делитель
            if (i != n / i) 
            {
                sum += n / i;
            }
        }
    }
    // Возвращаем сумму делителей
    return sum;
}

// Объявляем функцию для проверки, можно ли представить число в виде суммы квадратов двух натуральных чисел
pair<int, int> check_sum_of_squares(int n) 
{
    // Перебираем все возможные значения первого числа от 1 до корня из числа
    for (int a = 1; a <= sqrt(n); a++) 
    {
        // Вычисляем остаток от вычитания квадрата первого числа из заданного числа
        int b2 = n - a * a;
        // Вычисляем корень из остатка
        int b = sqrt(b2);
        // Если остаток является полным квадратом, то возвращаем пару чисел a и b
        if (b * b == b2) 
        {
            return make_pair(a, b);
        }
    }
    // Если такой пары не нашлось, то возвращаем пару нулей
    return make_pair(0, 0);
}

// Объявляем функцию для решения задачи «Вычислитель»
void solve_computer(string filename)
{
    // Открываем файл с натуральными числами для чтения
    ifstream file(filename);
    // Проверяем, что файл успешно открыт
    if (file.is_open())
    {
        // Создаем параллельную область с четырьмя потоками
#pragma omp parallel num_threads(4)
        {
            // Создаем параллельные секции для каждого клиента
#pragma omp sections
            {
                // Секция для первого клиента, который ищет наименьшее простое число больше считанного
#pragma omp section
                {
                    // Считываем число из файла, пока он не закончился
                    int number = read_number(file);
                    while (number != -1)
                    {
                        // Находим наименьшее простое число больше считанного
                        int next_prime = find_next_prime(number);
                        // Выводим ответ на экран в формате: номер потока, прочитанное число, ответ
                        cout << "[Thread " << omp_get_thread_num() << "]: " << number << " -> " << next_prime << endl;
                        // Считываем следующее число из файла
                        number = read_number(file);
                    }
                }
                // Секция для второго клиента, который строит наибольшее число Фибоначчи, которое не превосходит считанное
#pragma omp section
                {
                    // Считываем число из файла, пока он не закончился
                    int number = read_number(file);
                    while (number != -1)
                    {
                        // Находим наибольшее число Фибоначчи, которое не превосходит считанное
                        int max_fibonacci = find_max_fibonacci(number);
                        // Выводим ответ на экран в формате: номер потока, прочитанное число, ответ
                        cout << "[Thread " << omp_get_thread_num() << "]: " << number << " -> " << max_fibonacci << endl;
                        // Считываем следующее число из файла
                        number = read_number(file);
                    }
                }
                // Секция для третьего клиента, который считает сумму всех делителей считанного числа, не включая само число и единицу
#pragma omp section
                {
                    // Считываем число из файла, пока он не закончился
                    int number = read_number(file);
                    while (number != -1)
                    {
                        // Считаем сумму всех делителей считанного числа, не включая само число и единицу
                        int sum = sum_of_divisors(number);
                        // Выводим ответ на экран в формате: номер потока, прочитанное число, ответ
                        cout << "[Thread " << omp_get_thread_num() << "]: " << number << " -> " << sum << endl;
                        // Считываем следующее число из файла
                        number = read_number(file);
                    }
                }
                // Секция для четвертого клиента, который проверяет число на возможность его представления в виде суммы квадратов двух натуральных чисел
#pragma omp section
                {
                    // Считываем число из файла, пока он не закончился
                    int number = read_number(file);
                    while (number != -1)
                    {
                        // Проверяем число на возможность его представления в виде суммы квадратов двух натуральных чисел
                        pair<int, int> squares = check_sum_of_squares(number);
                        // Выводим ответ на экран в формате: номер потока, прочитанное число, ответ
                        cout << "[Thread " << omp_get_thread_num() << "]: " << number << " -> ";
                        if (squares.first == 0)
                        {
                            // Если число не может быть представлено в виде суммы квадратов двух натуральных чисел, то выводим 0
                            cout << "0" << endl;
                        }
                        else
                        {
                            // Если число может быть представлено в виде суммы квадратов двух натуральных чисел, то выводим эти числа
                            cout << squares.first << "^2 + " << squares.second << "^2" << endl;
                        }
                        // Считываем следующее число из файла
                        number = read_number(file);
                    }
                }
            }
        }
    }
}

int main(int argc, char* argv[]) 
{
    setlocale(LC_ALL, ("ru"));
    // Проверяем, что программа получила один аргумент - имя файла с числами
    if (argc == 2) 
    {
        // Вызываем нашу функцию solve_computer с именем файла
        solve_computer(argv[1]);
    }
    else 
    {
        // Выводим сообщение об ошибке
        cout << "Передайте два аргумента, название программы и название текстового файла" << endl;
    }
    // Возвращаем код завершения программы
    return 0;
}